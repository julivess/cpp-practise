# Vector

В этой задаче вам нужно реализовать упрощенный аналог шаблонного класса `std::vector`.
Для этого определите класс `Vector`, в котором будут храниться инты и есть:

* Конструктор по умолчанию.
* Конструктор, принимающий размер вектора и заполняющий его нулями.
* Конструктор, принимающий список инициализации `std::initializer_list<int>`,
что позволит писать `Vector a = {1, 3, 5}`.
* Конструктор копирования и конструктор перемещения.
* Операторы присваивания, копирующий и перемещающий.
* Деструктор.
* Метод `Swap`, принимающий другой вектор по ссылке и меняющий содержимое текущего вектора с ним местами.
* Операторы индексирования [ ], константный и нет. Последний должен позволять изменять содержимое по индексу.
* Метод `Size`, возвращающий число элементов в векторе.
* Метод `Capacity`, возвращающий текущее число выделенных ячеек памяти под вектор.
* Метод `PushBack`, который вставляет элемент в конец вектора.
Если при этом память, выделенная для вектора, заполнена, то выполните
реаллокацию: выделите массив вдвое большего размера, скопируйте элементы туда,
после чего удалите старый массив. В этом случае `Capacity` также должен увеличиться вдвое.
Для вектора, сконструированного с помощью конструктора по умоланию, `Capacity == 0`.
Если добавить элемент в такой вектор, то после этого `Capacity` должен стать равен `1`.
* Метод `PopBack`, который удаляет последний элемент вектора. Сужать вектор при этом не нужно, должен измениться только `Size`.
* Метод `Clear`, опустошающий вектор. Аналогично, сужать его при этом не нужно, `Size` должен стать нулевым.
* Метод `Reserve`, который принимает новое значение `capacity`, позволяя зарезервировать место в векторе.
Если текущий `Capacity` не меньше переданного, то метод не должен ничего делать. В противном случае выполните реаллокацию в массив размера `capacity`.
* Методы `begin` и `end`, возвращающие итераторы на первый элемент вектора
и на элемент следующий за последним.

Реализуйте итератор `Vector::Iterator`. Он должен быть random access,
т.е. должен удовлетворять следующим [требованиям](https://en.cppreference.com/w/cpp/named_req/RandomAccessIterator).

### Примечания

* В этой задаче вам запрещено использовать стандартные контейнеры и умные указатели, поэтому аккуратно управляйте памятью.
* Согласно требованиям к stl-совместимому итератору, в нём должны быть определены некоторые типы,
такие как `value_type` и некоторые другие. Они написаны за вас.
* Iterator должен быть неконстантным, т.е. с его помощью можно изменять элементы последовательности (см. тесты).
* Обратите внимание, что range-based for работает с коллекцией только в том случае,
если в ней есть методы `begin` и `end` или определены
внешние функции `begin` и `end`, принимающие заданную коллекцию.
Именно поэтому мы определяем эти методы в классе с именами, не соответствующими стайлгайду.
Эти имена будут игнорироваться при проверке clang-tidy (см. файл `.clang-tidy`
в корне репозитория), как и имена типов, объявленых внутри `Vector::Iterator`.
* Вместо того, чтобы писать 6 функций сравнения итераторов (`==`, `!=`, `<`, `<=`, `>`, `>=`),
можно воспользоваться дефолтным оператором [трёхстороннего сравнения](https://en.cppreference.com/w/cpp/language/default_comparisons#Defaulted_three-way_comparison):
```c++
auto operator<=>(const Iterator&) const = default;
```
